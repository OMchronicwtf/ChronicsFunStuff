local OrionLib = loadstring(game:HttpGet(('https://raw.githubusercontent.com/shlexware/Orion/main/source')))()
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Camera = game.Workspace.CurrentCamera

local player = Players.LocalPlayer
local mouse = player:GetMouse()

local targetPart = nil
local lockOnHeld = false
local aimbotEnabled = false
local autoLockEnabled = false
local lockOnKey = Enum.UserInputType.MouseButton2 -- Default keybind for locking on (right mouse button)
local lockOnRadius = 20 -- Lock-on radius
local fovAngle = 60 -- Field of View angle in degrees
local visualizerEnabled = false -- Start with visualizer off
local horizontalOffset = 0 -- Initial horizontal offset
local verticalOffset = -19 -- Initial vertical offset
local teamCheckEnabled = false -- Start with team checking off
local excludedTeam = nil -- No team excluded initially

-- FOV Visualizer Setup
local fovVisualizer = Instance.new("ScreenGui")
fovVisualizer.Name = "FOVVisualizer"
fovVisualizer.Parent = player.PlayerGui
fovVisualizer.Enabled = visualizerEnabled -- Control visibility with this property

local fovFrame = Instance.new("Frame")
fovFrame.Name = "FOVFrame"
fovFrame.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
fovFrame.BackgroundTransparency = 0.5
fovFrame.AnchorPoint = Vector2.new(0.5, 0.5)
fovFrame.Position = UDim2.new(0.5 + (horizontalOffset / Camera.ViewportSize.X), 0, 0.5 + (verticalOffset / Camera.ViewportSize.Y), 0)
fovFrame.Parent = fovVisualizer

local fovCorner = Instance.new("UICorner")
fovCorner.CornerRadius = UDim.new(0.5, 0) -- Makes the frame circular
fovCorner.Parent = fovFrame

local function updateFOVVisualizer()
    if not visualizerEnabled then
        fovVisualizer.Enabled = false
        return
    end

    fovVisualizer.Enabled = true
    local viewportSize = Camera.ViewportSize
    local fovRadius = math.tan(math.rad(fovAngle / 2)) * viewportSize.Magnitude / 2

    -- Adjust the scaling factor to make the visualizer size more accurate
    local diameter = math.max(fovRadius * 2 / (viewportSize.Magnitude / 750), 5) -- Adjusted minimum size
    fovFrame.Size = UDim2.new(0, diameter, 0, diameter)
    fovFrame.Position = UDim2.new(0.5 + (horizontalOffset / Camera.ViewportSize.X), 0, 0.5 + (verticalOffset / Camera.ViewportSize.Y), 0)
end

local function getAngleBetween(vector1, vector2)
    return math.acos(math.clamp(vector1:Dot(vector2), -1, 1)) * (180 / math.pi)
end

local function getPrioritizedTarget()
    local nearestPart = nil
    local closestDistance = math.huge
    local playerPosition = player.Character and player.Character.PrimaryPart.Position or Vector3.new()
    local cameraCFrame = Camera.CFrame
    local cameraLookVector = cameraCFrame.LookVector

    local players = Players:GetPlayers()
    for _, otherPlayer in pairs(players) do
        if otherPlayer ~= player and otherPlayer.Character then
            if teamCheckEnabled and excludedTeam and otherPlayer.Team == excludedTeam then
                continue
            end
            
            local humanoid = otherPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                for _, partName in ipairs({"Head", "UpperTorso", "LowerTorso", "LeftArm", "RightArm", "LeftLeg", "RightLeg"}) do
                    local part = otherPlayer.Character:FindFirstChild(partName)
                    if part then
                        local distance = (part.Position - playerPosition).magnitude
                        local screenPosition, isOnScreen = Camera:WorldToViewportPoint(part.Position)
                        if isOnScreen and distance < lockOnRadius then
                            local partVector = (part.Position - cameraCFrame.Position).unit
                            local angle = getAngleBetween(cameraLookVector, partVector)
                            if angle < fovAngle / 2 then
                                -- Prioritize by distance and health
                                if distance < closestDistance then
                                    closestDistance = distance
                                    nearestPart = part
                                elseif distance == closestDistance and humanoid.Health < (nearestPart.Parent:FindFirstChildOfClass("Humanoid") or {Health = math.huge}).Health then
                                    nearestPart = part
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    return nearestPart
end

local function lockOnTarget(target)
    local tween = TweenService:Create(Camera, TweenInfo.new(0.1, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = CFrame.new(Camera.CFrame.Position, target.Position)})
    tween:Play()
end

local function updateAimbot()
    if aimbotEnabled then
        if autoLockEnabled then
            local target = getPrioritizedTarget()
            if target then
                lockOnTarget(target)
            end
        end
        -- Manual lock-on logic
        if lockOnHeld then
            local target = getPrioritizedTarget()
            if target then
                lockOnTarget(target)
            end
        end
    end
end

-- Orion GUI Setup
local Window = OrionLib:MakeWindow({Name = "Chronic's Aimbot", HidePremium = false, SaveConfig = true, ConfigFolder = "AimbotConfig"})

local aimbotTab = Window:MakeTab({
    Name = "Aimbot Settings",
    Icon = "rbxassetid://4483345998",
    PremiumOnly = false
})

aimbotTab:AddBind({
    Name = "Toggle Aimbot",
    Hold = false,
    Callback = function()
        aimbotEnabled = not aimbotEnabled
        if aimbotEnabled then
            OrionLib:MakeNotification({
                Name = "Aimbot Enabled",
                Content = "Aimbot is now enabled.",
                Image = "rbxassetid://4483345998",
                Time = 2
            })
        else
            if autoLockEnabled then
                autoLockEnabled = false -- Disable auto-lock if aimbot is turned off
                OrionLib:MakeNotification({
                    Name = "Aimbot Disabled",
                    Content = "Aimbot is now disabled. Auto-Lock has been disabled.",
                    Image = "rbxassetid://4483345998",
                    Time = 2
                })
            else
                OrionLib:MakeNotification({
                    Name = "Aimbot Disabled",
                    Content = "Aimbot is now disabled.",
                    Image = "rbxassetid://4483345998",
                    Time = 2
                })
            end
        end
    end    
})

aimbotTab:AddBind({
    Name = "Toggle Auto-Lock",
    Default = autoLockKey,
    Hold = false,
    Callback = function()
        if aimbotEnabled then
            autoLockEnabled = not autoLockEnabled
            OrionLib:MakeNotification({
                Name = "Auto-Lock Toggled",
                Content = "Auto-Lock is now " .. (autoLockEnabled and "enabled" or "disabled"),
                Image = "rbxassetid://4483345998",
                Time = 2
            })
        else
            OrionLib:MakeNotification({
                Name = "Aimbot Disabled",
                Content = "Please enable aimbot before using auto-lock.",
                Image = "rbxassetid://4483345998",
                Time = 2
            })
        end
    end    
})

aimbotTab:AddSlider({
    Name = "Lock-on Radius",
    Min = 10,
    Max = 100,
    Default = lockOnRadius,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "Radius",
    Callback = function(value)
        lockOnRadius = value
    end    
})

aimbotTab:AddSlider({
    Name = "FOV Angle",
    Min = 10,
    Max = 180,
    Default = fovAngle,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "Angle",
    Callback = function(value)
        fovAngle = value
        updateFOVVisualizer() -- Update the visualizer when the FOV angle changes
    end    
})

local visualizerTab = Window:MakeTab({
    Name = "Visual Settings",
    Icon = "rbxassetid://4483345998",
    PremiumOnly = false
})

visualizerTab:AddToggle({
    Name = "Toggle FOV Visualizer",
    Default = visualizerEnabled,
    Callback = function(value)
        visualizerEnabled = value
        updateFOVVisualizer() -- Update the visualizer based on the toggle state
    end    
})

visualizerTab:AddSlider({
    Name = "FOV Visualizer Horizontal Offset",
    Min = -200,
    Max = 200,
    Default = horizontalOffset,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "Offset",
    Callback = function(value)
        horizontalOffset = value
        updateFOVVisualizer() -- Update the visualizer position when the offset changes
    end    
})

visualizerTab:AddSlider({
    Name = "FOV Visualizer Vertical Offset",
    Min = -200,
    Max = 200,
    Default = verticalOffset,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "Offset",
    Callback = function(value)
        verticalOffset = value
        updateFOVVisualizer() -- Update the visualizer position when the offset changes
    end    
})

local teamSettingsTab = Window:MakeTab({
    Name = "Team Settings",
    Icon = "rbxassetid://4483345998",
    PremiumOnly = false
})

teamSettingsTab:AddToggle({
    Name = "Enable Team Check",
    Default = teamCheckEnabled,
    Callback = function(value)
        teamCheckEnabled = value
    end    
})

teamSettingsTab:AddDropdown({
    Name = "Exclude Team",
    Options = {"None", "Red", "Blue"}, -- Adjust these options based on your gameâ€™s teams
    Default = "None",
    Callback = function(value)
        excludedTeam = value == "None" and nil or value
    end    
})

local OtherTab = Window:MakeTab({
    Name = "Other Settings",
    Icon = "rbxassetid://4483345998",
    PremiumOnly = false
})

OtherTab:AddButton({
    Name = "Destroy GUI",
    Callback = function()
        OrionLib:Destroy()
        fovVisualizer:Destroy() -- Clean up the visualizer
    end    
})

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end

    if input.KeyCode == Enum.KeyCode.F then
        aimbotEnabled = not aimbotEnabled
        if aimbotEnabled then
            OrionLib:MakeNotification({
                Name = "Aimbot Enabled",
                Content = "Aimbot is now enabled.",
                Image = "rbxassetid://4483345998",
                Time = 2
            })
        else
            if autoLockEnabled then
                autoLockEnabled = false -- Disable auto-lock if aimbot is turned off
                OrionLib:MakeNotification({
                    Name = "Aimbot Disabled",
                    Content = "Aimbot is now disabled. Auto-Lock has been disabled.",
                    Image = "rbxassetid://4483345998",
                    Time = 2
                })
            else
                OrionLib:MakeNotification({
                    Name = "Aimbot Disabled",
                    Content = "Aimbot is now disabled.",
                    Image = "rbxassetid://4483345998",
                    Time = 2
                })
            end
        end
    end

    if input.KeyCode == autoLockKey then
        if aimbotEnabled then
            autoLockEnabled = not autoLockEnabled
            OrionLib:MakeNotification({
                Name = "Auto-Lock Toggled",
                Content = "Auto-Lock is now " .. (autoLockEnabled and "enabled" or "disabled"),
                Image = "rbxassetid://4483345998",
                Time = 2
            })
        else
            OrionLib:MakeNotification({
                Name = "Aimbot Disabled",
                Content = "Please enable aimbot before using auto-lock.",
                Image = "rbxassetid://4483345998",
                Time = 2
            })
        end
    end

    if input.UserInputType == lockOnKey then
        if aimbotEnabled then
            lockOnHeld = true
        end
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == lockOnKey then
        lockOnHeld = false
    end
end)

RunService.RenderStepped:Connect(function()
    updateAimbot()
    updateFOVVisualizer() -- Continuously update the visualizer
end)

OrionLib:Init()
